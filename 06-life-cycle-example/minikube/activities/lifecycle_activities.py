"""
Activities para demostrar lifecycle completo en Kubernetes.
"""

import asyncio
import os
import socket
import time
from datetime import datetime
from typing import Dict, Any

from temporalio import activity


# VersiÃ³n del worker (se actualiza en CI/CD)
WORKER_VERSION = os.getenv("WORKER_VERSION", "v1.0.0-local")
BUILD_TIME = os.getenv("BUILD_TIME", datetime.now().isoformat())
GIT_COMMIT = os.getenv("GIT_COMMIT", "unknown")


@activity.defn
async def get_worker_info(*args, **kwargs) -> Dict[str, Any]:
    """
    Obtiene informaciÃ³n del worker que ejecuta la activity.
    """
    activity.logger.info(f"ðŸ“‹ Getting worker info - Version: {WORKER_VERSION}")
    
    # Simular trabajo
    await asyncio.sleep(2)
    
    worker_info = {
        "version": WORKER_VERSION,
        "build_time": BUILD_TIME,
        "git_commit": GIT_COMMIT,
        "hostname": socket.gethostname(),
        "pod_name": os.getenv("HOSTNAME", "unknown"),
        "namespace": os.getenv("NAMESPACE", "unknown"),
        "node_name": os.getenv("NODE_NAME", "unknown"),
        "timestamp": datetime.now().isoformat()
    }
    
    activity.logger.info(f"âœ… Worker info: {worker_info['hostname']} - {worker_info['version']}")
    return worker_info


@activity.defn
async def process_chunk(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Procesa un chunk de trabajo (simula procesamiento largo).
    """
    minute = params["minute"]
    total = params["total"]
    
    activity.logger.info(f"â³ Processing chunk {minute}/{total} on worker {WORKER_VERSION}")
    
    # Simular trabajo pesado
    await asyncio.sleep(30)  # 30 segundos de trabajo
    
    result = {
        "minute": minute,
        "total": total,
        "worker_version": WORKER_VERSION,
        "hostname": socket.gethostname(),
        "processing_time": 30,
        "timestamp": datetime.now().isoformat()
    }
    
    activity.logger.info(f"âœ… Chunk {minute}/{total} completed on {WORKER_VERSION}")
    return result


@activity.defn
async def validate_processing(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Valida el procesamiento realizado.
    """
    workflow_id = params["workflow_id"]
    
    activity.logger.info(f"ðŸ” Validating processing for workflow: {workflow_id}")
    
    # Simular validaciÃ³n
    await asyncio.sleep(5)
    
    # Simular diferentes resultados segÃºn la versiÃ³n
    if "v2" in WORKER_VERSION:
        validation_score = 95  # VersiÃ³n nueva es mejor
    else:
        validation_score = 85  # VersiÃ³n vieja
    
    result = {
        "workflow_id": workflow_id,
        "validation_score": validation_score,
        "worker_version": WORKER_VERSION,
        "hostname": socket.gethostname(),
        "checks_passed": validation_score > 80,
        "timestamp": datetime.now().isoformat()
    }
    
    activity.logger.info(f"âœ… Validation completed: {validation_score}% on {WORKER_VERSION}")
    return result


@activity.defn
async def generate_lifecycle_report(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Genera reporte final del lifecycle.
    """
    workflow_id = params["workflow_id"]
    worker_versions = params["worker_versions"]
    steps = params["steps"]
    start_time = params["start_time"]
    
    activity.logger.info(f"ðŸ“Š Generating lifecycle report for: {workflow_id}")
    
    # Simular generaciÃ³n de reporte
    await asyncio.sleep(3)
    
    # Analizar versiones de workers utilizados
    unique_versions = list(set(worker_versions))
    version_changes = len(unique_versions) > 1
    
    report = {
        "workflow_id": workflow_id,
        "execution_summary": {
            "start_time": start_time,
            "end_time": datetime.now().isoformat(),
            "total_steps": len(steps),
            "worker_versions_used": unique_versions,
            "version_changes_detected": version_changes,
            "rollout_detected": version_changes
        },
        "worker_analysis": {
            "total_version_calls": len(worker_versions),
            "unique_versions": unique_versions,
            "version_distribution": {
                version: worker_versions.count(version) 
                for version in unique_versions
            }
        },
        "lifecycle_insights": {
            "demonstrates_replay": True,
            "demonstrates_rollout": version_changes,
            "demonstrates_coexistence": len(unique_versions) > 1,
            "worker_resilience": "PASSED"
        },
        "generated_by": {
            "worker_version": WORKER_VERSION,
            "hostname": socket.gethostname(),
            "timestamp": datetime.now().isoformat()
        }
    }
    
    activity.logger.info(f"âœ… Lifecycle report generated by {WORKER_VERSION}")
    return report


@activity.defn
async def quick_test(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Test rÃ¡pido para verificar deployment.
    """
    test_id = params["test_id"]
    
    activity.logger.info(f"ðŸ§ª Quick test: {test_id} on {WORKER_VERSION}")
    
    # Test bÃ¡sico
    await asyncio.sleep(5)
    
    result = {
        "test_id": test_id,
        "worker_version": WORKER_VERSION,
        "hostname": socket.gethostname(),
        "test_result": "PASSED",
        "response_time_ms": 5000,
        "timestamp": datetime.now().isoformat()
    }
    
    activity.logger.info(f"âœ… Quick test passed on {WORKER_VERSION}")
    return result


@activity.defn
async def simulate_failure() -> Dict[str, Any]:
    """
    Simula fallo para testing de retry policies.
    """
    activity.logger.info(f"ðŸ’¥ Simulating failure on {WORKER_VERSION}")
    
    # Simular fallo aleatorio
    import random
    if random.random() < 0.7:  # 70% chance de fallo
        raise Exception(f"Simulated failure on worker {WORKER_VERSION}")
    
    return {
        "status": "SUCCESS",
        "worker_version": WORKER_VERSION,
        "timestamp": datetime.now().isoformat()
    }


@activity.defn
async def version_specific_feature(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Feature que solo existe en versiones nuevas.
    """
    feature_name = params.get("feature_name", "unknown")
    
    activity.logger.info(f"ðŸ†• Version-specific feature: {feature_name} on {WORKER_VERSION}")
    
    # Solo funciona en v2+
    if "v1" in WORKER_VERSION:
        raise Exception(f"Feature '{feature_name}' not available in {WORKER_VERSION}")
    
    await asyncio.sleep(2)
    
    result = {
        "feature_name": feature_name,
        "worker_version": WORKER_VERSION,
        "status": "FEATURE_AVAILABLE",
        "timestamp": datetime.now().isoformat()
    }
    
    activity.logger.info(f"âœ… Feature {feature_name} executed on {WORKER_VERSION}")
    return result